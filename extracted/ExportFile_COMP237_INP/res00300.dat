<?xml version="1.0" encoding="UTF-8"?>
<CONTENT id="_800662_1"><TITLE value="Topic 3.2 Search algorithms"/><TITLECOLOR value="#000000"/><DESCRIPTION
   value=""/><BODY><TEXT>&lt;div data-layout-row="52c4c974-bbb5-44ac-a9d8-7c5f37bc4139"&gt;&lt;div data-layout-column="2618f837-fe23-43d5-9e1b-65f46f578af3" data-layout-column-width="12"&gt;&lt;div data-bbid="bbml-editor-id_c103a3fd-0063-4b0e-a732-f20aedbb53c5"&gt;&lt;h4&gt;Topic 3.2 Search algorithms&amp;nbsp;&lt;/h4&gt;&lt;br&gt;&lt;h5&gt;&lt;span style="color: #1c8845"&gt;Tree search&lt;/span&gt;&lt;/h5&gt;&lt;br&gt;&lt;p&gt;The &lt;span style="color: #000000"&gt;&lt;strong&gt;search tree&lt;/strong&gt;&lt;/span&gt; describes paths between states reaching towards the &lt;span style="color: #000000"&gt;&lt;strong&gt;goal&lt;/strong&gt;&lt;/span&gt;.&amp;nbsp;&lt;/p&gt;&lt;p&gt;The search tree may have multiple paths to any given state, but each node in the tree has a &lt;span style="color: #000000"&gt;&lt;strong&gt;unique path back to the root&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;Remember our example of finding the shortest path from Arad to Bucharest in Romania, explained in Topic 3.1. The below figure shows the first few steps in finding a path. We can expand the node by considering the available &lt;span style="color: #000000"&gt;&lt;strong&gt;Actions&lt;/strong&gt;&lt;/span&gt; for that state, using the resulting function to see where those actions lead to and generating new nodes called the &lt;span style="color: #000000"&gt;&lt;strong&gt;child nodes&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt; &lt;/span&gt;or &lt;span style="color: #000000"&gt;&lt;strong&gt;successor nodes&lt;/strong&gt;&lt;/span&gt;.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;a href="@X@EmbeddedFile.requestUrlStub@X@bbcswebdav/xid-1692638_1" data-bbtype="attachment" data-bbfile="{&amp;quot;alternativeText&amp;quot;:&amp;quot;Partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are shaded; nodes that have been generated but not yet expanded are outlined in bold; nodes that have not&amp;quot;,&amp;quot;linkName&amp;quot;:&amp;quot;Tree_Expansions.png&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;render&amp;quot;:&amp;quot;inline&amp;quot;}"&gt;Tree_Expansions.png&lt;/a&gt;&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;span style="font-size: 0.875rem;"&gt;Partial search trees for finding a route from Arad to Bucharest. Nodes that have been expanded are shaded; nodes that have been generated but not yet expanded are outlined in bold; nodes that have not yet been generated are shown in faint dashed lines.&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;Redundant paths &amp;amp; Cycles&lt;/h5&gt;&lt;p&gt;Consider the four-state graph illustrated in the figure below:&lt;/p&gt;&lt;p&gt;&lt;a href="@X@EmbeddedFile.requestUrlStub@X@bbcswebdav/xid-1692639_1" data-bbtype="attachment" data-bbfile="{&amp;quot;alternativeText&amp;quot;:&amp;quot;Four state graph with cycle&amp;quot;,&amp;quot;linkName&amp;quot;:&amp;quot;four_state_graph.png&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;render&amp;quot;:&amp;quot;inline&amp;quot;}"&gt;four_state_graph.png&lt;/a&gt;&lt;/p&gt;&lt;p&gt;If we were to ask how big is the search tree from &lt;span style="color: #000000"&gt;&lt;strong&gt;S (start)&lt;/strong&gt;&lt;/span&gt; to &lt;span style="color: #000000"&gt;&lt;strong&gt;G (goal)&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt;, t&lt;/span&gt;he answer would be infinity &lt;span style="color: #000000"&gt;&lt;span style="font-size: 1.125rem;"&gt;&lt;strong&gt;∞ &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt;&lt;span style="font-size: 0.875rem;"&gt;and that is because there is a cycle in this graph between a and b.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Accordingly, there will be lots of repeated structures in the search tree! &lt;span style="color: #000000"&gt;&lt;strong&gt;Loopy paths&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt; &lt;/span&gt;are a special case of the more general concept of &lt;span style="color: #000000"&gt;&lt;strong&gt;redundant paths&lt;/strong&gt;&lt;/span&gt;, which exist whenever there is more than one way to get from one state to another&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;span style="color: #1c8845"&gt;&lt;strong&gt;&lt;em&gt;Algorithms that forget their history are doomed to repeat it.&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;The way to avoid exploring redundant paths is to remember where one has been.&amp;nbsp;&lt;span style="font-size: 0.875rem;"&gt;To do this, we:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"Augment the TREE-SEARCH algorithm with a data structure called the&lt;span style="color: #000000"&gt;&lt;strong&gt; EXPLORED SET&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt; &lt;/span&gt; (also&amp;nbsp;known as the&lt;strong&gt; &lt;/strong&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;CLOSED LIST&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;), which remembers every expanded node. Newly generated nodes that match previously generated nodes—ones in the explored set or the frontier—can be discarded instead of being added to the frontier. The new algorithm, called &lt;span style="color: #000000"&gt;&lt;strong&gt;GRAPH-SEARCH&lt;/strong&gt;&lt;/span&gt;."&lt;/p&gt;&lt;br&gt;&lt;h5&gt;&lt;strong&gt;Search data structure&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;Search algorithms require a data structure to keep track of the search tree that is being constructed.&lt;/p&gt;&lt;p&gt;For each node &lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt; of the tree, we have a structure that contains four components:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;node.STATE:&lt;/strong&gt;&lt;/span&gt; the state in the state space to which the node corresponds.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;node.PARENT&lt;/strong&gt;&lt;/span&gt;: the node in the search tree that generated this node.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;node.ACTION:&lt;/strong&gt;&lt;/span&gt; the action that was applied to the parent to generate the node.&lt;/li&gt;&lt;li style="font-size: 0.875rem;
          padding-left: 1.319rem;"&gt;&lt;span style="color: #000000"&gt;&lt;span style="font-size: 0.875rem;"&gt;&lt;strong&gt;node.PATH-COST:&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="font-size: 0.875rem;"&gt; the cost, traditionally denoted by &lt;/span&gt;&lt;span style="color: #000000"&gt;&lt;span style="font-size: 0.875rem;"&gt;g(node)&lt;/span&gt;&lt;/span&gt;&lt;span style="font-size: 0.875rem;"&gt;, of the path from the initial state&amp;nbsp;&lt;/span&gt;to the node, as indicated by the parent pointers.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let's have a look at the example below:&lt;/p&gt;&lt;p&gt;&lt;a href="@X@EmbeddedFile.requestUrlStub@X@bbcswebdav/xid-1692640_1" data-bbtype="attachment" data-bbfile="{&amp;quot;alternativeText&amp;quot;:&amp;quot;Node represented by aa data structure with four components&amp;quot;,&amp;quot;linkName&amp;quot;:&amp;quot;Node_representation.png&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;render&amp;quot;:&amp;quot;inline&amp;quot;,&amp;quot;width&amp;quot;:871,&amp;quot;height&amp;quot;:326.21722846441946}"&gt;Node_representation.png&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Nodes are the data structures from which the search tree is constructed. Each one has a parent, a state, and various book keeping fields. Arrows point from child to parent.&lt;/p&gt;&lt;p&gt;From the above figure, the configuration of the 8-puzzle game board is a state and the parent node is the one that generated this configuration.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Now, we need a data structure to store the &lt;span style="color: #000000"&gt;&lt;strong&gt;frontier&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt;.&amp;nbsp;&lt;/span&gt;The appropriate data structure for this is a &lt;span style="color: #000000"&gt;&lt;strong&gt;queue&lt;/strong&gt;&lt;/span&gt;. The &lt;span style="color: #000000"&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/span&gt;&amp;nbsp;&lt;span style="color: #000000"&gt;&lt;strong&gt;operations&lt;/strong&gt;&lt;/span&gt; on a queue are as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;IS-EMPTY?(frontier)&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;returns true only if there are no more elements in the queue.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;POP(frontier)&lt;/strong&gt;&lt;/span&gt;&amp;nbsp;removes the first element of the queue and returns it.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;TOP(frontier)&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;returns the first element but does not remove the top node.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;ADD(node, frontier)&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;inserts an element and returns the resulting queue.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Three&amp;nbsp;&lt;span style="color: #000000"&gt;&lt;strong&gt;kinds of queues&lt;/strong&gt;&lt;/span&gt; are used in search algorithms:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;A Priority queue&lt;/strong&gt;&lt;/span&gt;: first pops the node with the &lt;span style="color: #000000"&gt;&lt;strong&gt;minimum cost&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt;, we will see and discuss this once we discuss the Uniform cost search in Topic 3.6.&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;A FIFO queue&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;: First in first out queue pops the node that was added to queue first. we will see this once we discuss the Breadth first search in Topic 3.5.&lt;/li&gt;&lt;li&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;A LIFO queue&lt;/strong&gt;&lt;/span&gt;: Last in first out also known as a &lt;span style="color: #000000"&gt;&lt;strong&gt;stack&lt;/strong&gt;&lt;/span&gt;&lt;span style="color: #000000"&gt; we will see this once we discuss the Depth first search in Topic 3.4.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5&gt;Search strategies&lt;/h5&gt;&lt;p&gt;For any problem, we need to carry out the following steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Formulate the problem.&lt;/li&gt;&lt;li&gt;Map the states into a structure (graph/ tree).&lt;/li&gt;&lt;li&gt;Investigate &amp;amp; develop a plan based on a&lt;span style="color: #000000"&gt;&lt;strong&gt; strategy&lt;/strong&gt;&lt;/span&gt;.&lt;/li&gt;&lt;li&gt;Act according to a plan.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;So, it is key to identify a &lt;span style="color: #000000"&gt;&lt;strong&gt;strategy&lt;/strong&gt;&lt;/span&gt;, which is an algorithm that the agent follows in his search to come up with a plan to solve the problem.&lt;/p&gt;&lt;p&gt;There are of many strategies (Algorithms) available, but we can classify these into two main categories:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Informed search&lt;/li&gt;&lt;li&gt;Uninformed search&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The main difference is that, in &lt;strong&gt;informed search algorithms&lt;/strong&gt;, the agent can estimate how far it is from the goal, while in &lt;strong&gt;uninformed search algorithms&lt;/strong&gt; the agent has no information about the goal.&lt;/p&gt;&lt;p&gt;The figure below clarifies some of the most known algorithms that are widely used today under each category:&lt;/p&gt;&lt;p&gt;&lt;a href="@X@EmbeddedFile.requestUrlStub@X@bbcswebdav/xid-1692641_1" data-bbtype="attachment" data-bbfile="{&amp;quot;alternativeText&amp;quot;:&amp;quot;Search strategies&amp;quot;,&amp;quot;linkName&amp;quot;:&amp;quot;search_strategies.png&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;render&amp;quot;:&amp;quot;inline&amp;quot;,&amp;quot;width&amp;quot;:941.7750244140625,&amp;quot;height&amp;quot;:445.57805245702383}"&gt;search_strategies.png&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In this module we will explain the Depth first search (DFS), Breadth first search (BFS), Uniform Cost search (UCS) algorithms and there implementations. In Module four, we go over the Greedy search and A* algorithms.&lt;/p&gt;&lt;h5&gt;Measuring problem solving performance&lt;/h5&gt;&lt;p&gt;Before we get into the design of specific search algorithms, we need to consider the criteria that might be used to choose among them. As per the below diagram we can evaluate an algorithm’s performance in four ways:&lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;a href="@X@EmbeddedFile.requestUrlStub@X@bbcswebdav/xid-1692642_1" data-bbtype="attachment" data-bbfile="{&amp;quot;alternativeText&amp;quot;:&amp;quot;Problem solving performance criteria&amp;quot;,&amp;quot;linkName&amp;quot;:&amp;quot;Performance criteria.png&amp;quot;,&amp;quot;mimeType&amp;quot;:&amp;quot;image/png&amp;quot;,&amp;quot;render&amp;quot;:&amp;quot;inline&amp;quot;}"&gt;Performance criteria.png&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;Completeness:&lt;/strong&gt;&lt;/span&gt; Is the algorithm guaranteed to find a solution when there is one?&lt;/p&gt;&lt;p&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;Optimality:&lt;/strong&gt;&lt;/span&gt;&amp;nbsp;Does the strategy find the optimal solution (Lowest-cost)&lt;/p&gt;&lt;p&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;Time complexity:&lt;/strong&gt;&lt;/span&gt; How long does it take to find a solution?&lt;/p&gt;&lt;p&gt;&lt;span style="color: #000000"&gt;&lt;strong&gt;Space complexity:&lt;/strong&gt;&lt;/span&gt; How much memory is needed to perform the search?&lt;/p&gt;&lt;h5&gt;Branching factor (b)&lt;/h5&gt;&lt;p&gt;The branching factor&amp;nbsp;- the average number of children of the nodes in the space.&lt;/p&gt;&lt;p&gt;The average branching factor can be quickly calculated as: The number of &lt;span style="color: #000000"&gt;&lt;strong&gt;non-root nodes&lt;/strong&gt;&lt;/span&gt; (the size of the tree, minus one) divided by the number of&lt;span style="color: #000000"&gt;&lt;strong&gt; non-leaf nodes&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;We will refer back to this criteria when we explain the algorithms.&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;h5&gt;References&lt;/h5&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Artificial intelligence a modern approach&lt;/strong&gt; by Stuart J. Russell and Peter Norvig , chapter 3&lt;/li&gt;&lt;li&gt;Hands- On Artificial Intelligence for Search by Devangini Patel Chapter 1&amp;nbsp;&lt;/li&gt;&lt;li&gt;UC Berkeley CS188 Intro to AI &lt;a href="http://ai.berkeley.edu/home.html"&gt;http://ai.berkeley.edu/home.html&lt;/a&gt;&amp;nbsp;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=r7P9sy5Rar8"&gt;https://www.youtube.com/watch?v=r7P9sy5Rar8&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</TEXT><TYPE
   value="H"/></BODY><DATES><CREATED value="2024-10-04 18:31:42 EDT"/><UPDATED value="2024-11-11 19:32:46 EST"/><START
   value=""/><END value=""/></DATES><FLAGS><ISAVAILABLE value="true"/><ISFROMCARTRIDGE value="false"/><ISFOLDER
   value="false"/><ISDESCRIBED value="false"/><ISTRACKED value="true"/><ISLESSON value="false"/><ISSEQUENTIAL
   value="false"/><ALLOWGUESTS value="true"/><ALLOWOBSERVERS value="true"/><LAUNCHINNEWWINDOW
   value="false"/><ISREVIEWABLE value="false"/><ISGROUPCONTENT value="false"/><ISSAMPLECONTENT
   value="false"/><PARTIALLYVISIBLE value="false"/><HASTHUMBNAIL value="false"/></FLAGS><CONTENTHANDLER
  value="resource/x-bb-document"/><RENDERTYPE value="REGULAR"/><FOLDERTYPE value=""/><URL value=""/><VIEWMODE
  value="TEXT_ICON_ONLY"/><OFFLINENAME value=""/><OFFLINEPATH value=""/><LINKREF value=""/><PARENTID
  value="_800497_1"/><REVIEWABLEREASON value="NONE"/><VERSION value="3"/><THUMBNAILALT value=""/><AISTATE
  value="No"/><AIACCEPTINGUSER value=""/><EXTENDEDDATA/><FILES/></CONTENT>
